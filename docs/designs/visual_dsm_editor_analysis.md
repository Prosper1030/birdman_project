# **yEd 圖形編輯器技術分析報告：為視覺化依賴關係編輯器提供實作藍圖**

## **前言**

### **報告目的**

本報告旨在對 yEd 圖形編輯器進行深度技術解構與分析，其最終目標是為一個基於 Python 與 PyQt5 的專案管理應用程式，提供一份詳盡的「視覺化依賴關係編輯器」架構藍圖。報告內容將專注於可直接轉化為程式碼的核心互動邏輯、底層資料模型、關鍵佈局演算法，以及最終生成設計結構矩陣 (Design Structure Matrix, DSM) 的完整流程。

### **分析方法**

本分析基於對 yEd 桌面應用程式使用者介面與互動行為的逆向工程，並結合其底層核心函式庫 yFiles 的官方技術文件進行深入研究 。此方法不僅能解析其「功能為何」，更能推斷其「如何實作」以及「為何如此設計」，從而為目標專案提供具備高度可行性的技術建議。

### **報告結構**

本報告將依序探討以下四個核心部分：

1. **核心使用者互動模式解構**：詳細拆解使用者建立與編輯圖形元素（任務節點與依賴關係邊）的完整操作流程與狀態轉換。

2. **底層圖形資料架構推斷**：推導並以 JSON 格式範例展示 yEd 在後端用於儲存圖形資訊的資料結構。

3. **關鍵自動佈局演算法分析**：剖析三種對於專案管理情境最具應用價值的自動佈局演算法，闡述其核心原理與適用場景。

4. **技術規格與實作路線圖**：將所有分析結果彙整為一份結構化的技術規格文件，並提供一個從圖形介面到 DSM 矩陣生成的完整實作藍圖。

---

## **第一部分：核心使用者互動模式解構**

本節旨在細緻地拆解使用者在 yEd 中建立和操作相依性圖表的基礎互動行為。其目標是定義一套清晰、事件驅動的邏輯，以便能直接對應到 PyQt5 的信號與槽 (signal and slot) 機制。此處將節點（任務）與邊（依賴關係）的生命週期視為獨立的狀態機進行分析。

### **1\.1 節點（任務）生命週期：建立、選取與修改**

節點的互動邏輯圍繞著其建立、選取、移動和屬性編輯等操作展開。

#### **建立機制**

yEd 提供了兩種主要的節點建立方式，這兩種方式對應著不同的使用者意圖和操作流程。

1. **從面板拖放 (Drag-and-Drop from Palette)**：這是最主要且直觀的建立方式。使用者從介面側邊的「面板 (Palette)」工具窗格中，透過滑鼠拖曳手勢 (mouse drag gesture) 將一個預設的節點樣本拖曳至主編輯畫布上 。在 PyQt5 中，此操作可透過為面板元件啟用

   `QDrag` 事件來實現。拖曳的有效負載 (payload) 應包含要建立的節點類型、預設樣式等資訊。當使用者在畫布上釋放滑鼠時，畫布的 `dropEvent` 會被觸發，進而根據負載資訊在指定位置建立一個新的 `QGraphicsItem` 節點。

2. **直接點擊畫布 (Direct Canvas Click)**：yEd 提供一個可選設定（`Create Node on Background Click`），允許使用者透過在畫布的空白處單擊滑鼠左鍵來快速建立一個預設節點. 這種方式對應到

   `QGraphicsView` 的 `mousePressEvent` 事件。事件處理器必須先判斷點擊位置是否存在圖形元素；若無，則在該座標建立新節點。若點擊位置已有元素，則應執行選取或取消選取的邏輯。

#### **選取與取消選取**

使用者介面的響應性很大程度上取決於流暢的選取邏輯。

- **單選與取消**：在節點上單擊滑鼠左鍵以選取該節點。在畫布的任何空白區域單擊，則會取消所有已選取的元素 。

- **多重選取**：按住 `SHIFT` 或 `CTRL` 鍵的同時點擊多個節點，可以實現標準的多重選取功能 。

- **結構視圖連動**：yEd 的「結構視圖 (Structure View)」以樹狀列表展示了圖形的層級關係。在此視圖中點擊一個節點條目，主編輯畫布上對應的節點也會同步被選取 。這暗示了模型與多個視圖之間的狀態同步機制。



#### **編輯節點屬性**

節點的屬性編輯主要分為標籤文字和視覺樣式兩部分。

- **標籤編輯**：節點上的文字標籤支援多行編輯 。此編輯狀態通常透過緩慢的雙擊或選取節點後按下

   `F2` 鍵來觸發。進入編輯模式後，可以在節點上方覆蓋一個 `QLineEdit` 或 `QTextEdit` 元件，讓使用者輸入文字。編輯完成後（例如，失去焦點或按下 `Enter`），元件隱藏，其內容更新至節點的資料模型和視覺呈現上。

- **屬性面板編輯**：節點的大部分其他屬性，如顏色、形狀、尺寸和自訂資料，都是透過專用的「屬性視圖 (Properties View)」面板進行修改 。當一個節點被選取時，此面板會動態填充該節點的所有可編輯屬性。使用者在面板上所做的任何更改，都應即時反映到畫布上的節點外觀上。

### **1\.2 邊（依賴關係）生命週期：基於狀態的連接建立分析**

建立一條邊（即任務間的依賴關係）是一個典型的狀態機過程，對使用者體驗至關重要。若將此流程分解，可以清晰地定義出應用程式在不同階段應有的行為和視覺回饋。

- 狀態一：起始 (Initiation) - 選取源節點

   使用者將滑鼠游標移動到一個作為起點的節點上，按下左鍵並開始拖曳 。此操作始於一個在

   `QGraphicsItem` 節點上觸發的 `mousePressEvent`。應用程式在此刻必須記錄下源節點的唯一識別碼 (ID)，並將自身狀態從「閒置 (Idle)」切換至「建立邊線中 (Edge Creation)」。

- 狀態二：視覺回饋 (Dragging) - 拖曳過程

   當滑鼠從源節點拖出時，一條預覽線（通常稱為「橡皮筋線, rubber band」）會從源節點的連接埠即時繪製到當前的滑鼠游標位置 。這需要在畫布的

   `mouseMoveEvent` 中不斷重繪這條臨時線段。為了提供更明確的指示，滑鼠游標的圖示也應變更為連接狀態的樣式 。在 PyQt 中，這可以透過在

   `QGraphicsView` 的 `paintEvent` 中繪製一條臨時線段來實現，該線段的終點隨 `mouseMoveEvent` 不斷更新。

- 狀態三：目標識別 (Hovering) - 游標懸停

   當滑鼠游標懸停在一個有效的目標節點上時，該目標節點應提供視覺回饋，例如邊框高亮或顏色變化，以告知使用者此處是一個有效的放置目標。

- 狀態四：完成 (Completion) - 建立連接

   當使用者將滑鼠拖曳到一個有效的目標節點上並釋放左鍵時，整個手勢結束 。在目標節點上觸發的

   `mouseReleaseEvent` 標誌著連接的最終確認。此時，應用程式應在後端資料模型中建立一條永久的、從源節點指向目標節點的邊，並在畫布上繪製出對應的 `QGraphicsLineItem`（或自訂的邊物件）。隨後，應用程式狀態應返回至「閒置」。

- 狀態五：中斷 (Abort) - 取消操作

   在釋放滑鼠之前的任何時刻，使用者都可以透過按下 ESC 鍵或點擊滑鼠右鍵來取消正在進行的邊建立操作 。這要求應用程式在「建立邊線中」狀態下，同時監聽

   `keyPressEvent` (針對 `ESC` 鍵) 和 `mousePressEvent` (針對右鍵)。一旦觸發，應立即清除預覽線，並將狀態重設為「閒置」。

- 狀態六：建立彎折點 (Bends) - 繪製折線

   yEd 支援建立多段式的折線邊。如果使用者在拖曳後，將滑鼠釋放在畫布的空白區域，則會在該位置建立一個「彎折點 (bend)」。之後的每一次左鍵單擊都會增加一個新的彎折點，直到最後一次單擊落在一個目標節點上，才算完成整個邊的建立 。這個功能為狀態機增加了額外的複雜性，需要引入一個中間的「放置彎折點 (Placing Bends)」狀態。



### **互動邏輯的架構性啟示**



yEd 的互動邏輯並非單一的龐大結構，而是由一系列定義明確、相對獨立的狀態機（如節點建立、邊線建立、文字編輯）所組成。這強烈暗示了在 PyQt5 中的實作也應遵循模組化原則。為每個核心互動設計獨立的事件處理邏輯，並在主視窗或場景控制器中設立一個中央狀態管理器（例如，一個枚舉變數來追蹤當前是 `IDLE`, `CREATING_EDGE`, 還是 `EDITING_TEXT` 狀態），將是構建一個清晰、可擴展且不易出錯的編輯器的關鍵。這種架構可以有效防止衝突操作（如在建立一條邊的過程中又嘗試開始另一條），並簡化每個事件處理函式的邏輯，因為它只需關注當前狀態下的行為。

此外，yEd 廣泛使用上下文選單（右鍵選單）來提供與當前選取物件相關的功能 。這是一個提升專業感和操作效率的關鍵使用者體驗模式。為了模擬這一點，

`contextMenuEvent` 處理器不應提供一個靜態選單，而應動態地檢查游標下的物件類型（節點、邊或畫布背景），並根據該上下文即時建構並顯示對應的 `QMenu`。例如，節點的選單可能包含「編輯標籤」、「刪除」；邊的選單可能包含「新增彎折點」、「反轉方向」；而畫布的選單則可能提供「貼上」、「全選」、「套用佈局」等選項。

---

## **第二部分：底層圖形資料架構推斷**

本節旨在逆向工程化 yEd 用於表示圖形的核心資料模型。儘管 yEd 的原生檔案格式是基於 XML 的 GraphML ，但為了便於開發和整合，此處將定義一個功能等價且對開發者友善的 JSON 結構。設計此模型的關鍵在於，它不僅要能完整描述視覺化所需的全部資訊，還必須具備良好的擴充性，以容納專案管理所需的特定領域資料，並能輕易地被後續的分析演算法（如 DSM 生成）所取用。

### **2\.1 核心圖形模型：資料的基礎**

從根本上說，編輯器所操作的對象是一個有向圖 G=(V,E)，其中 V 是頂點（節點/任務）的集合，而 E 則是頂點有序對（邊/依賴關係）的集合。

#### **節點 (Task) 屬性**

圖中的每一個節點，為了能夠被正確地識別和渲染，至少需要包含以下屬性：

- `id`: 一個全域唯一的識別碼（例如，UUID 字串或整數）。這是邊列表中引用節點的基礎，至關重要。

- `label`: 顯示在節點上的文字，即任務名稱（例如，「任務 A：設計使用者介面」）。

- `position`: 一個包含 `x` 和 `y` 座標的物件，用於定義節點在畫布上的位置。

- `geometry`: 一個包含 `width` 和 `height` 的物件，用於渲染、邊緣連接點計算和碰撞偵測。

#### **邊 (Dependency) 屬性**

每一條邊代表一個從源節點到目標節點的有向關係：

- `id`: 邊本身的唯一識別碼。

- `source`: 起始節點的 `id`。

- `target`: 目標節點的 `id`。

- `bends` (可選): 一個由 `{x, y}` 座標物件組成的陣列，用於定義折線路徑上的所有彎折點。

#### **專案管理的擴充性**

yEd 的一個強大之處在於其允許使用者為圖形元素附加任意的自訂屬性 **6**。對於專案管理應用而言，這項能力是不可或缺的。因此，我們的資料模型必須包含一個靈活的容器來儲存這些額外資訊，例如任務的「負責人」、「狀態」、「預計工時」等。

### **2\.2 JSON 格式的表述模型**

基於上述分析，一個能夠完整描述專案依賴關係圖的 JSON 結構範例如下。該結構設計清晰，易於被程式解析、操作及序列化。

**JSON**

```json
{
  "graph": {
    "id": "project_alpha_dependencies",
    "nodes":,
    "edges":
  }
}

```

### **資料模型的架構性啟示**

將資料模型與視圖分離是現代應用程式架構（也是 yFiles 函式庫所遵循的）的基本原則 **1**。上述 JSON 結構即為「模型 (Model)」，而 PyQt5 的

`QGraphicsScene` 則是「視圖 (View)」。應用程式的業務邏輯，即為「控制器 (Controller)」。嚴格遵守這種 MVC (Model-View-Controller) 或類似的設計模式，對於開發一個可維護、可擴展的應用程式至關重要。

具體而言，這個架構的運作流程應如下：

1. 使用者在「視圖」上的操作（例如，拖曳一個節點）不應直接修改其他視圖元件。

2. 相反地，「視圖」應發出一個信號（例如，`nodeMoved(nodeId, newPosition)`）。

3. 「控制器」邏輯捕捉到這個信號，並去更新「模型」（即記憶體中的圖形資料結構）。

4. 最後，「控制器」根據更新後的「模型」來通知「視圖」進行重繪。

這種解耦的架構帶來了巨大的好處：資料模型可以被獨立地儲存、載入和分析（例如，生成 DSM），完全不受使用者介面的影響。同時，它也為未來的功能擴展奠定了基礎，例如，可以用多種不同的視圖（如圖形視圖、表格視圖、甘特圖視圖）來呈現同一份資料模型。

此外，關於 `id` 欄位的選擇也值得深思。雖然使用簡單的整數（如 1, 2, 3）在單一圖形中是可行的，但採用全域唯一識別碼 (UUID) 是一個更具前瞻性的架構決策。當未來需要合併來自不同專案的圖形時——這在大型專案管理中是個常見需求——UUID 可以從根本上避免 ID 衝突的問題。這個決策以極小的實作成本，換取了系統長期的強健性與可擴展性。

---

## **第三部分：關鍵自動佈局演算法分析**

yEd 最核心的競爭優勢之一，在於其提供了一套功能強大且高度可配置的自動佈局演算法 。對於專案管理應用而言，佈局不僅僅是為了美觀，它本身就是一種強大的分析工具，能夠揭示任務間的內在結構。本節將分析三種對專案管理情境最為有用的佈-局演算法，並深入探討其核心原理、適用場景及其在 yFiles 文件中揭示的底層機制。

### **3\.1 階層式佈局 (Hierarchical Layout)**

#### **核心原理**

階層式佈局，也稱為 Sugiyama-style 演算法，其核心目標是將圖中的節點排列在不同的層級中，以突顯圖形中的主要「流向」或方向性 。它特別適用於有向無環圖 (DAG)，或只有少量迴圈的圖。該演算法的執行過程主要分為三個階段 ：

1. **分層 (Layer Assignment)**：演算法將所有節點分配到不同的水平或垂直層級。其首要目標是讓絕大多數的邊都朝著同一個方向（例如，從上到下或從左到右），並盡可能減少指向上游的「回邊 (back-edges)」。

2. **交叉最小化 (Crossing Reduction / Sequencing)**：在每個層級內部，演算法會重新排列節點的順序，以最小化相鄰層級之間邊的交叉數量。這是確保圖形可讀性的關鍵步驟。

3. **座標分配 (Coordinate Assignment / Drawing)**：確定所有節點的最終 (x, y) 座標，以產生一個整潔、美觀的佈局。同時，演算法會根據設定的風格（如直線、折線或曲線）來佈線邊的路徑。

#### **專案管理適用性**

階層式佈局是視覺化具有明確前置任務約束流程的理想選擇 。它在專案管理中的應用場景包括：

- **計畫評核術 (PERT) 與要徑法 (CPM)**：清晰地展示任務的執行序列，並能直觀地識別出專案的「要徑 (critical path)」。

- **瀑布式專案計畫**：完美地視覺化專案各階段的線性進程（例如：需求 -> 設計 -> 開發 -> 測試）。

- **工作流程圖 (BPMN-like)**：適用於呈現任何具有先後順序的步驟化流程，例如審批流程或生產流程 。

### **3\.2 正交佈局 (Orthogonal Layout)**

#### **核心原理**

正交佈局的核心特點是，所有的邊都僅由水平和垂直的線段構成，且轉角均為 90 度 。它通常基於「拓撲-形狀-度量 (topology-shape-metrics)」的方法，透過最小化邊的交叉和彎折數量來優先保證結構的清晰度 **20**。此演算法旨在產生一個緊湊、類似網格的佈局，非常適合呈現複雜的連接關係。

#### **專案管理適用性**

相較於階層式佈局專注於「流程」，正交佈局更擅長於清晰地解開複雜、非線性的依賴關係網。其主要應用場景為：

- **系統架構圖**：在軟體開發專案中，用於展示不同模組、元件或微服務之間的呼叫和依賴關係。

- **複雜專案的依賴關係圖譜**：當一個任務有多個前置依賴，或同時是多個後續任務的依賴時，其依賴關係網會變得錯綜複雜。此時，正交佈局能比其他佈局產生更清晰、更易於追蹤的圖譜。

- **組織結構與溝通路徑**：當節點代表團隊或個人，邊代表必要的溝通或工作交接時，正交佈局能清晰地展示組織內的協作網絡。

### **3\.3 力導向佈局 (Force-Directed Layout / Organic Layout)**

#### **核心原理**

此演算法，在 yEd 中稱為「有機佈局 (Organic Layout)」，其原理是模擬一個物理系統 。

- **相斥力 (Repulsive Forces)**：將每個節點視為帶有相同電荷的粒子。根據庫倫定律，它們會互相排斥，從而避免節點重疊，並在它們之間創造出空間。

- 吸引力 (Attractive Forces)：將每條邊視為連接兩個節點的彈簧。根據虎克定律，彈簧會將相連的節點拉近。

   演算法透過反覆運算，計算作用在每個節點上的合力，並移動節點，直到整個系統達到一個能量最低的平衡狀態 25。最終的結果是，關聯性強的節點會自然地被拉到一起，形成「叢集 (clusters)」。

#### **專案管理適用性**

力導向佈局的目的不在於展示嚴格的執行順序，而在於**發現**隱藏在依賴關係中的內在結構。它特別適用於：

- **敏捷專案管理**：視覺化一個衝刺 (Sprint) 中所有使用者故事 (User Stories) 和任務之間的關係網，可以快速看出哪些工作項目是緊密耦合的。

- **識別任務叢集/模組**：演算法能自動將高度相互依賴的任務群組在一起。這個結果可以為工作分解結構 (WBS) 的劃分或團隊任務的分配提供重要參考。

- **瓶頸分析**：在佈局中，具有大量連接的節點（即中心度高的節點）通常會成為視覺上的「樞紐」，這使得專案經理可以直觀地識別出潛在的瓶頸任務或關鍵的整合點。

### **表 3.1：專案管理佈局演算法比較**

| **演算法** | **核心原理** | **專案管理適用場景** | **優點** | **缺點** | 
|---|---|---|---|---|
| **階層式 (Hierarchical)** | 節點分層以顯示定向流  | 瀑布式專案、PERT/CPM 圖、流程工作流  | 清晰展示優先順序和序列 | 對於多迴圈圖效果不佳；可能產生較寬或較長的佈局 | 
| **正交式 (Orthogonal)** | 基於網格，90度邊緣佈線  | 複雜的依賴關係圖、系統架構視覺化  | 極度清晰整潔，最大限度減少歧義 | 可能佔用更多空間；佈局感覺可能不夠「自然」 | 
| **力導向 (Force-Directed)** | 吸引力與排斥力的物理模擬 | 敏捷專案、發現任務叢集、瓶頸分析  | 揭示內在結構，美觀 | 結果非確定性；不適合展示明確的執行順序 | 

### **佈局演算法的架構性啟示**

佈局演算法的選擇不僅僅是美學考量，它本身就是一種分析行為。不同的佈局演算法能揭示專案結構的不同面向。一個功能強大的依賴關係編輯器不應強迫使用者接受單一佈局，而應允許他們在不同佈局之間自由切換，以獲得多維度的洞察。例如，專案經理可能首先使用階層式佈局來驗證整體的流程設計是否合理；接著切換到力導向佈局，觀察是否出現了意料之外的任務叢集，這可能意味著需要調整團隊分工；最後，在正式的設計審查會議上，使用正交佈局來生成一份清晰、無歧義的圖表。因此，實作的重點不應是只選擇一種演算法，而是應該建立一個類似 yEd 的「佈局」選單，讓使用者可以按需套用任何一種佈局。這將使該功能從一個簡單的繪圖工具，提升為一個強大的互動式分析平台。

此外，這些演算法的性能，特別是力導向佈局，在處理大型圖形時可能會有較大的計算開銷。為了保證使用者介面的流暢性，必須考慮將佈局計算過程放置在一個獨立的背景執行緒中執行。在 PyQt5 中，這可以透過 `QThread` 來實現。主執行緒負責觸發佈局計算，而工作執行緒在完成計算後，透過信號將更新後的節點座標傳回給主執行緒。主執行緒的槽函式接收到新座標後，再更新 `QGraphicsScene` 上的元素位置。這是確保應用程式在處理日益增長的專案圖形時，仍能提供良好使用者體驗的關鍵性實作細節。

---

## **第四部分：技術規格與實作路線圖**

本節將前述所有分析結果，整合成一個具體、可執行的開發計畫。它首先提供了使用者所要求的、可直接寫入技術規格文件的結構化文字，接著推薦了一套經過論證的技術棧，並最終勾勒出從圖形介面操作到生成設計結構矩陣 (DSM) 的端到端實作藍圖。

### **4\.1 視覺化編輯器功能需求 ([`Requirements.md`](Requirements.md))**

# **視覺化依賴關係編輯器功能規格**

## **1\.0 畫布與互動**

1\.1 編輯器應提供一個可無限滾動的畫布用於圖形建立。

1\.2 畫布應支援平移（滑鼠右鍵拖曳或中鍵拖曳）與縮放（滑鼠滾輪）操作 。

1\.3 編輯器應支援網格線顯示與對齊網格功能，以輔助手動對齊 。

## **2\.0 節點（任務）管理**

2\.1 使用者應能透過從元件面板拖放預定義圖形的方式在畫布上建立節點 。

2\.2 使用者應能透過在畫布背景單擊滑鼠左鍵的方式快速建立節點 。

2\.3 每個節點必須有一個可編輯的多行文字標籤 。

2\.4 使用者應能使用標準的滑鼠手勢選取、移動和縮放節點。

2\.5 應提供一個屬性面板，用於顯示和編輯所選節點的屬性（例如：顏色、形狀，以及如「指派對象」、「狀態」等自訂資料欄位）。

## **3\.0 邊（依賴關係）管理**

3\.1 使用者應能透過從源節點拖曳至目標節點的方式建立有向邊 。

3\.2 在建立邊的過程中，UI 必須提供即時的視覺回饋（如「橡皮筋」預覽線） 。

3\.3 邊的建立過程必須可以透過按下 ESC 鍵或點擊滑鼠右鍵來取消 。

3\.4 邊應支援可編輯的文字標籤。

## **4\.0 自動佈局**

4\.1 編輯器必須提供一個「佈局」選單，內含多種自動佈局演算法。

4\.2 至少應實作以下演算法：

\- 階層式 (Hierarchical)：用於視覺化循序性的任務流程 。

\- 正交式 (Orthogonal)：用於清晰地展示複雜的相互依賴關係 。

\- 力導向 (Force-Directed/Organic)：用於探索和發現任務的自然分組 。

## **5\.0 DSM 生成**

5\.1 應用程式必須提供一個功能，能將當前的有向圖轉換為一個設計結構矩陣 (Design Structure Matrix, DSM)。

5\.2 DSM 應為一個 N×N 的矩陣，其中 N 為任務（節點）的總數。

5\.3 矩陣中 Matrix\[i, j\] 的標記表示任務 i 是任務 j 的一個依賴項（即存在一條從 i 指向 j 的邊）。

5\.4 生成的 DSM 應能在應用程式內的一個表格視圖中顯示。

### **4\.2 推薦的 Python 技術棧**

- **GUI 框架**: `PyQt5` (依使用者指定)。

- **圖形視覺化**: `PyQtGraph` 。

   - **理由**: 雖然 `Matplotlib` 可以被嵌入到 PyQt5 應用中 **30**，但其設計初衷是為了生成靜態的、出版品質的圖表，對於即時互動式應用的性能並未最佳化 **32**。相比之下，

      `PyQtGraph` 是基於 Qt 原生的 `QGraphicsView` 框架建構的，為平移、縮放和即時資料更新等操作提供了顯著更優的性能。對於需要流暢編輯體驗的本專案而言，`PyQtGraph` 是架構上更優越的選擇。

- **後端圖形管理與分析**: `NetworkX`。

   - **理由**: `NetworkX` 是 Python 社群中用於建立、操作和研究圖形結構的事實標準函式庫。它提供了強健的 `DiGraph` 物件，完美適用於模擬依賴關係圖。更重要的是，它內建了將圖形匯出為 NumPy 陣列（即鄰接矩陣）的關鍵功能，這是生成 DSM 的核心步驟 **36**。

- **數值運算**: `NumPy` 。

   - **理由**: 作為 `NetworkX` 匯出鄰接矩陣的目標格式，以及作為最終 DSM 的資料結構，`NumPy` 是不可或缺的。

### **4\.3 實作藍圖：從圖形到設計結構矩陣 (DSM)**

此藍圖清晰地定義了實現核心功能的端到端流程。

- **步驟一：UI 事件捕獲 (PyQtGraph / QGraphicsScene)**

   1. 繼承 `QGraphicsItem` 來建立自訂的 `NodeItem` 和 `EdgeItem` 類別。

   2. 在自訂的 `QGraphicsView` 或 `NodeItem` 類別中，實作 `mousePressEvent`, `mouseMoveEvent`, `mouseReleaseEvent` 等方法，以處理節點拖曳和前述的邊建立狀態機。

   3. 當一個使用者操作完成時（例如，節點被移動，邊被建立），發出一個自訂的 PyQt 信號，並附帶相關資料（例如 `nodeMoved(node_id, new_pos)`，`edgeCreated(source_id, target_id)`）。

- **步驟二：後端資料模型更新 (NetworkX)**

   1. 在應用程式的主類別中，維護一個 `networkx.DiGraph` 的實例。這個物件就是整個應用的「模型」。

   2. 建立對應的槽函式，並將它們連接到步驟一中定義的信號。這些槽函式負責更新 `networkx` 圖物件。例如，`edgeCreated` 信號會觸發 `G.add_edge(source_id, target_id)`。節點的位置等視覺屬性可以作為節點屬性儲存：`G.nodes[node_id]['pos'] = new_pos`。

- **步驟三：轉換為鄰接矩陣 (NetworkX -> NumPy)**

   1. 這是 DSM 生成的核心。當使用者點擊「生成 DSM」按鈕時，呼叫 [`networkx.to`](networkx.to)`_numpy_array()` 函式 。

   2. 為了確保矩陣的行和列順序是穩定且可預測的，必須先定義一個節點列表：`nodelist = list(G.nodes)`。

   3. 然後使用此列表進行轉換：`adjacency_matrix = `[`nx.to`](nx.to)`_numpy_array(G, nodelist=nodelist)`。

- **步驟四：顯示 DSM (NumPy -> QTableWidget)**

   1. `adjacency_matrix` 是一個 NumPy 陣列。可以使用這個陣列來填充一個 `QTableWidget`，或者為了更佳的性能和擴展性，使用一個帶有自訂 `QAbstractTableModel` 的 `QTableView`。

   2. 表格的行和列標頭應使用步驟三中建立的 `nodelist` 來填充。

   3. **慣例對應**: 在 DSM 中，一個位於 `(row_i, col_j)` 的標記通常表示「任務 i 為任務 j 提供輸入」或「任務 i 是任務 j 的前置任務」 。

      `NetworkX` 的 `to_numpy_array` 對於一個有向圖，若存在一條從節點 `u` 到 `v` 的邊，則會在矩陣的 `A[u, v]` 位置標記為 1。這與 DSM 的慣例完全吻合，即 `Matrix[i, j] = 1` 代表任務 `i` 必須在任務 `j` 之前完成。在 UI 中呈現時，應向使用者清晰說明此對應關係。

### **最終架構性啟示**

從宏觀角度看，整個專案可以被視為是為 `NetworkX` 函式庫建構一個客製化的圖形化前端。視覺化編輯器的本質是一個讓使用者能夠直觀地建構 `NetworkX` 圖物件的工具，而 DSM 的生成則僅僅是呼叫 `NetworkX` 的一個內建函式。這個觀點極大地簡化了專案的複雜性，並突顯了將 UI 邏輯 (`PyQtGraph`) 與資料/分析邏輯 (`NetworkX`) 嚴格分離的重要性。

最後，DSM 的生成不僅僅是一個資料轉換步驟，它更是進一步分析的起點。真正的 DSM 方法論還包括對矩陣進行重排序（稱為**分區 (Partitioning)** 和**撕裂 (Tearing)**），以最小化回饋迴圈並識別模組化的任務群組 。雖然實作這些高級的重排序演算法可能超出了初始專案的範圍，但在報告中提及此點，可以為應用程式的未來發展提供一個清晰的路線圖，使其從一個簡單的圖表工具，演進為一個真正強大的專案管理分析平台。